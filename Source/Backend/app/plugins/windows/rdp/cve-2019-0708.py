NAME = 'CVE-2019-0708'

import ssl
import argparse
import sys
import traceback
import struct
import socket
import hashlib
import string
import random
import os
import sys
from binascii import unhexlify, hexlify
from ipaddress import IPv4Network
from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa,padding
from cryptography.hazmat.primitives import hashes
SEC_ENCRYPT = 0x08
SEC_INFO_PKT = 0x40
STATUS_VULNERABLE = "VULNERABLE"
STATUS_UNKNOWN = "UNKNOWN"
STATUS_NORDP = "NO RDP"
STATUS_SAFE = "SAFE"
NEGOTIATION_FAILURED = ["UNKNOWN_ERROR",
    "SSL_REQUIRED_BY_SERVER",
    "SSL_NOT_ALLOWED_BY_SERVER",
    "SSL_CERT_NOT_ON_SERVER",
    "INCONSISTENT_FLAGS",
    "HYBRID_REQUIRED_BY_SERVER",
    "SSL_WITH_USER_AUTH_REQUIRED_BY_SERVER"]
class RC4:
    def __init__(self, key, streaming=True):
        assert(isinstance(key, (bytes, bytearray)))
        S = list(range(0x100))
        j = 0
        for i in range(0x100):
            j = (S[i] + key[i % len(key)] + j) & 0xff
            S[i], S[j] = S[j], S[i]
        self.S = S
        if streaming:
            self.keystream = self._keystream_generator()
        else:
            self.keystream = None
    def crypt(self, data):
        assert(isinstance(data, (bytes, bytearray)))
        keystream = self.keystream or self._keystream_generator()
        return bytes([a ^ b for a, b in zip(data, keystream)])
    def _keystream_generator(self):
        S = self.S.copy()
        x = y = 0
        while True:
            x = (x + 1) & 0xff
            y = (S[x] + y) & 0xff
            S[x], S[y] = S[y], S[x]
            i = (S[x] + S[y]) & 0xff
            yield S[i]
def pdu_connection_request(use_ssl = True):
    pkt = (
        b"\x03\x00\x00\x2b\x26\xe0\x00\x00\x00\x00\x00\x43\x6f\x6f\x6b\x69\x65\x3a\x20\x6d\x73\x74\x73\x68\x61\x73\x68\x3d" +
        ''.join(random.choice(string.ascii_letters)
                   for i in range(5)).encode("ascii") +
        b"\x0d\x0a\x01\x00\x08"
    )
    if not use_ssl:
        pkt += b"\x00\x00\x00\x00\x00"
    else:
        pkt += b"\x00\x01\x00\x00\x00"
    return pkt
def rdp_connect(sock, use_ssl):
    ip, port = sock.getpeername()
    res = rdp_send_recv(sock, pdu_connection_request(use_ssl))
    if res[0:2] == b'\x03\x00' and (res[5] & 0xf0) == 0xd0:
        if len(res) < 0xc or res[0xb] == 0x2:
            if len(res) < 0xc:
                return "nossl"
            else:
                return None
        elif res[0xb] == 0x3:
            fc = res[0xf]
            if fc > 6:
                fc = 0
            fcs = NEGOTIATION_FAILURED[fc]
            return fcs
    raise RdpCommunicationError()
def pdu_connect_initial(use_ssl):
    pkt = ("030001ca02f0807f658201be0401010401010101ff30200202002202020002020200000202000102020000020200010202ffff020200023020020200010202000102020001020200010202000002020001020204200202000230200202ffff0202fc170202ffff0202000102020000020200010202ffff020200020482014b000500147c00018142000800100001c00044756361813401c0d800040008002003580201ca03aa09040000280a0000"
    )
    pkt += ("780031003800310030000000000000000000000000000000000000000000000004000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ca010000000000180007000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
    if use_ssl:
        pkt += "01000000"
    else:
        pkt += "00000000"
    pkt += (
        "04c00c00090000000000000002c00c00030000000000000003c0440005000000636c697072647200c0a000004d535f543132300080800000726470736e640000c0000000736e646462670000c0000000726470647200000080800000")
    return unhexlify(pkt)
def pdu_erect_domain_request():
    pkt = (
        b"\x03\x00\x00\x0c\x02\xf0\x80\x04\x00\x01\x00\x01")
    return pkt
def pdu_attach_user_request():
    pkt = (
        b"\x03\x00\x00\x08\x02\xf0\x80\x28"
    )
    return pkt
def pdu_channel_request(user1, channel_id):
    pkt = (
        b"\x03\x00\x00\x0c\x02\xf0\x80\x38" +
        struct.pack('>HH', user1, channel_id)
    )
    return pkt
def pdu_security_exchange(rcran, rsexp, rsmod, bitlen):
    encrypted_rcran_bignum = rsa_encrypt(rcran, rsexp, rsmod)
    encrypted_rcran = int_to_bytestring(encrypted_rcran_bignum)
    bitlen += 8
    bitlen_hex = struct.pack("<L", bitlen)
    userdata_length = 8 + bitlen
    userdata_length_low = userdata_length & 0xFF
    userdata_length_high = userdata_length >> 8
    flags = 0x80 | userdata_length_high
    pkt = b"\x03\x00"
    pkt += struct.pack(">H", userdata_length+15)
    pkt += b"\x02\xf0\x80\x64\x00\x08\x03\xeb\x70"
    pkt += struct.pack("B", flags)
    pkt += struct.pack("B", userdata_length_low)
    pkt += b"\x01\x00\x00\x00"
    pkt += bitlen_hex
    pkt += encrypted_rcran
    pkt += b"\x00\x00\x00\x00\x00\x00\x00\x00"
    return pkt
def pdu_client_info():
    pkt = (
        "000000003301000000000a00000000000000000075007300650072003000000000000000000002001c003100390032002e003100360038002e0031002e0032003000380000003c0043003a005c00570049004e004e0054005c00530079007300740065006d00330032005c006d007300740073006300610078002e0064006c006c000000a40100004700540042002c0020006e006f0072006d0061006c0074006900640000000000000000000000000000000000000000000000000000000000000000000000000000000a00000005000300000000000000000000004700540042002c00200073006f006d006d006100720074006900640000000000000000000000000000000000000000000000000000000000000000000000000000000300000005000200000000000000c4ffffff00000000270000000000"
    )
    return unhexlify(pkt)
def pdu_client_confirm_active():
    pkt = (
        "a4011300f103ea030100ea0306008e014d53545343000e00000001001800010003000002000000000d04000000000000000002001c00100001000100010020035802000001000100000001000000030058000000000000000000000000000000000000000000010014000000010047012a000101010100000000010101010001010000000000010101000001010100000000a1060000000000000084030000000000e40400001300280000000003780000007800000050010000000000000000000000000000000000000000000008000a000100140014000a0008000600000007000c00000000000000000005000c00000000000200020009000800000000000f000800010000000d005800010000000904000004000000000000000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000800010000000e0008000100000010003400fe000400fe000400fe000800fe000800fe001000fe002000fe004000fe008000fe000001400000080001000102000000")
    return unhexlify(pkt)
def pdu_client_persistent_key_list():
    pkt = (
        "49031700f103ea03010000013b031c00000001000000000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
    return unhexlify(pkt)
def rdp_parse_serverdata(pkt, ip):
    ptr = 0
    rdp_pkt = pkt[0x49:]
    while ptr < len(rdp_pkt):
        header_type = rdp_pkt[ptr:ptr+1+1]
        header_length = struct.unpack("<H", rdp_pkt[ptr+2:ptr+3+1])[0]
        if header_type == b"\x02\x0c":
            encryptionMethod = struct.unpack("<L", rdp_pkt[ptr+4:ptr+8])[0]
            encryptionLevel = struct.unpack("<L", rdp_pkt[ptr+8:ptr+12])[0]
            serverRandomLen = struct.unpack("<L", rdp_pkt[ptr+12:ptr+16])[0]
            serverCertLen = struct.unpack("<L", rdp_pkt[ptr+16:ptr+20])[0]
            server_random = rdp_pkt[ptr+20:ptr+20+serverRandomLen]
            rsran = int.from_bytes(server_random, "little")
            serverCertData = rdp_pkt[ptr+20+serverRandomLen:]
            if serverCertData[0] == 0x02:
                num_certs = struct.unpack("<L", serverCertData[4:8])[0]
                ptr = 8
                while num_certs > 0:
                    cert_len = struct.unpack("<L", serverCertData[ptr:ptr+4])[0]
                    cert_data = serverCertData[ptr+4:ptr+4+cert_len]
                    cert = x509.load_der_x509_certificate(cert_data, backend=default_backend())
                    from pyasn1_modules import pem, rfc2459,rfc4055
                    from pyasn1.codec.der import decoder
                    _cert = decoder.decode(cert_data, asn1Spec=rfc2459.Certificate())[0]
                    _pub_k = _cert["tbsCertificate"]["subjectPublicKeyInfo"]["subjectPublicKey"].asOctets()
                    _pk = decoder.decode(_pub_k, asn1Spec=rfc4055.RSAPublicKey())[0]
                    _mod = int(_pk['modulus'])
                    _exp = int(_pk['publicExponent'])
                    num_certs -= 1
                    ptr += 4 + cert_len
                if _mod and _exp:
                    rsmod = _mod
                    rsexp = _exp
                    bitlen = _mod.bit_length() // 8
                else:
                    raise RdpCommunicationError()
            else:
                rsa_magic = rdp_pkt[ptr+68:ptr+71+1]
                if rsa_magic != b"RSA1":
                    raise RdpCommunicationError()
                public_exponent = rdp_pkt[ptr+84:ptr+87+1]
                bitlen = struct.unpack("<L", rdp_pkt[ptr+72:ptr+75+1])[0] - 8
                modulus = rdp_pkt[ptr+88:ptr+87+bitlen+1]
                rsmod = int.from_bytes(modulus, "little")
                rsexp = int.from_bytes(public_exponent, "little")
        ptr += header_length
    return rsmod, rsexp, rsran, server_random, bitlen
class RdpCommunicationError(Exception):
    pass
def rdp_send(sock, data):
    sock.send(data)
def rdp_recv(sock):
    res1 = sock.recv(4)
    if res1 == b'':
        raise RdpCommunicationError()
    version = res1[0]
    if version == 3:
        l = struct.unpack(">H", res1[2:4])[0]
    else:
        l = res1[1]
        if l & 0x80:
            l &= 0x7f
            l = l * 256 + res1[2]
    if l < 4:
        raise RdpCommunicationError()
    res2 = b''
    remaining = l - 4
    while remaining:
        chunk = sock.recv(remaining)
        res2 += chunk
        remaining -= len(chunk)
    if res2 == b'':
        raise RdpCommunicationError()
    return res1 + res2
def rdp_send_recv(sock, data):
    rdp_send(sock, data)
    return rdp_recv(sock)
def rdp_encrypted_pkt(data, rc4enckey = None, hmackey = None, flags = 0,
                      flagsHi=0, channelId=b"\x03\xeb"):
    add_security_header = (flags & SEC_INFO_PKT) or hmackey
    add_security_header1 = hmackey
    userData_len = len(data)
    if add_security_header:
        userData_len += 4
    if add_security_header1:
        userData_len += 8
    udl_with_flag = 0x8000 | userData_len
    pkt = b"\x02\xf0\x80\x64\x00\x08"
    pkt += channelId
    pkt += b"\x70"
    pkt += struct.pack(">H", udl_with_flag)
    if add_security_header:
        pkt += struct.pack("<H", flags)
        pkt += struct.pack("<H", flagsHi)
    if add_security_header1:
        pkt += rdp_hmac(hmackey, data)[0:7+1]
    pkt += rdp_rc4_crypt(rc4enckey, data) if rc4enckey else data
    tpkt = b"\x03\x00"
    tpkt += struct.pack(">H", len(pkt) + 4)
    tpkt += pkt
    return tpkt
def rdp_decrypt_pkt(data, rc4deckey, ip):
    if not rc4deckey:
        return
    f = 0
    if data[0:2] == b'\x03\x00':
        t = data[0x07]
        if t == 0x68:
            if data[0x0d] & 0x80:
                l = (data[0x0d] & 0x7f) * 256 + data[0x0e]
                s = 0x0f
            else:
                l = data[0x0d]
                s = 0x0e
            f = struct.unpack(">H", data[s:s+2])[0]
            fh = struct.unpack(">H", data[s+2:s+4])[0]
            h = data[s+4:s+4+8]
            enc_data = data[s+12:]
    elif data[0] & 0x80:
        if data[1] & 0x80:
            s = 11
        else:
            s = 10
        enc_data = data[s:]
    else:
        return
    if (data[0] & 0x80) or (f & 0x0800):
        dec_data = rdp_rc4_crypt(rc4deckey, enc_data)
def try_check(sock, rc4enckey, hmackey, rc4deckey, encrypt_flag):
    ip, port = sock.getpeername()
    try:
        for i in range(5):
            res = rdp_recv(sock)
            rdp_decrypt_pkt(res, rc4deckey, ip)
    except RdpCommunicationError as ex:
        pass
    for j in range(6):
        pkt = rdp_encrypted_pkt(
            unhexlify("100000000300000000000000020000000000000000000000"),
            rc4enckey, hmackey, encrypt_flag, 0, b"\x03\xed")
        rdp_send(sock, pkt)
        pkt = rdp_encrypted_pkt(
            unhexlify("20000000030000000000000000000000020000000000000000000000000000000000000000000000"),
            rc4enckey, hmackey, encrypt_flag, 0, b"\x03\xed")
        rdp_send(sock, pkt)
        try:
            for i in range(1):
                res = rdp_recv(sock)
                rdp_decrypt_pkt(res, rc4deckey, ip)
                if unhexlify("0300000902f0802180") in res:
                    return STATUS_VULNERABLE
        except socket.timeout as ex:
            pass
        except RdpCommunicationError as ex:
            pass
    return STATUS_SAFE
def check_rdp_vuln(ip, port, use_ssl = True):
    try:
        try:
            sock = tcp_connect(ip, port)
        except Exception as ex:
            return STATUS_NORDP
        status = rdp_connect(sock, use_ssl)
        if status in ["SSL_NOT_ALLOWED_BY_SERVER", "SSL_CERT_NOT_ON_SERVER"]:
            use_ssl = False
            try:
                sock = tcp_connect(ip, port)
            except Exception as ex:
                return STATUS_NORDP
            status = rdp_connect(sock, use_ssl)
        if status == "nossl":
            status = None
            use_ssl = False
        elif status:
            return status
    except Exception as ex:
        return STATUS_NORDP
    if use_ssl:
        sock = ssl.wrap_socket(sock, ssl_version=ssl.PROTOCOL_TLSv1,
                                       cert_reqs=ssl.CERT_NONE,)
        encrypt_flag = 0
    else:
        encrypt_flag = SEC_ENCRYPT
    res = rdp_send_recv(sock, pdu_connect_initial(use_ssl))
    if encrypt_flag:
        rsmod, rsexp, rsran, server_rand, bitlen = rdp_parse_serverdata(res, ip)
    rdp_send(sock, pdu_erect_domain_request())
    res = rdp_send_recv(sock, pdu_attach_user_request())
    user1 = struct.unpack("!H", res[9: 9+2])[0]
    rdp_send_recv(sock, pdu_channel_request(user1, 1009))
    rdp_send_recv(sock, pdu_channel_request(user1, 1003))
    rdp_send_recv(sock, pdu_channel_request(user1, 1004))
    rdp_send_recv(sock, pdu_channel_request(user1, 1005))
    rdp_send_recv(sock, pdu_channel_request(user1, 1006))
    rdp_send_recv(sock, pdu_channel_request(user1, 1007))
    rdp_send_recv(sock, pdu_channel_request(user1, 1008))
    if encrypt_flag:
        client_rand = b"\x41" * 32
        rcran = int.from_bytes(client_rand, "little")
        rdp_send(sock, pdu_security_exchange(rcran, rsexp, rsmod, bitlen))
        rc4encstart, rc4decstart, hmackey, sessblob = rdp_calculate_rc4_keys(
            client_rand, server_rand)
        rc4enckey = RC4(rc4encstart)
        rc4deckey = RC4(rc4decstart)
    else:
        rc4enckey = None
        rc4deckey = None
        hmackey = None
    res = rdp_send_recv(sock, rdp_encrypted_pkt(
        pdu_client_info(), rc4enckey, hmackey, SEC_INFO_PKT | encrypt_flag ))
    rdp_decrypt_pkt(res, rc4deckey, ip)
    res = rdp_recv(sock)
    rdp_decrypt_pkt(res, rc4deckey, ip)
    rdp_send(sock, rdp_encrypted_pkt(
        pdu_client_confirm_active(), rc4enckey, hmackey, 0x30 | encrypt_flag))
    synch = rdp_encrypted_pkt(
        unhexlify("16001700f103ea030100000108001f0000000100ea03"), rc4enckey, hmackey, encrypt_flag)
    coop = rdp_encrypted_pkt(
        unhexlify("1a001700f103ea03010000010c00140000000400000000000000"), rc4enckey, hmackey, encrypt_flag)
    rdp_send(sock, synch + coop)
    rdp_send(sock, rdp_encrypted_pkt(
        unhexlify("1a001700f103ea03010000010c00140000000100000000000000"), rc4enckey, hmackey, encrypt_flag))
    rdp_send(sock, rdp_encrypted_pkt(
        pdu_client_persistent_key_list(), rc4enckey, hmackey, encrypt_flag))
    rdp_send(sock, rdp_encrypted_pkt(
        unhexlify("1a001700f103ea03010000010c00270000000000000003003200"), rc4enckey, hmackey, encrypt_flag))
    result = try_check(sock, rc4enckey, hmackey, rc4deckey, encrypt_flag)
    if result == STATUS_VULNERABLE:
        pass
    return result
def tcp_connect(ip, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)
    s.settimeout(5.0)
    s.connect((ip, port))
    return s
def check(ip, port=3389, use_ssl = True):
    status = STATUS_UNKNOWN
    try:
        try:
            status = check_rdp_vuln(ip, port, use_ssl)
        except Exception as ex:
            raise ex
    except Exception as ex:
        pass
    return True if status == STATUS_VULNERABLE else False
def rdp_hmac(mac_salt_key, data_content):
    sha1 = hashlib.sha1()
    md5 = hashlib.md5()
    pad1 = b"\x36" * 40
    pad2 = b"\x5c" * 48
    sha1.update(mac_salt_key)
    sha1.update(pad1)
    sha1.update(struct.pack("<L", len(data_content)))
    sha1.update(data_content)
    md5.update(mac_salt_key)
    md5.update(pad2)
    md5.update(sha1.digest())
    return md5.digest()
def rdp_salted_hash(s_bytes, i_bytes, clientRandom_bytes, serverRandom_bytes):
    sha1 = hashlib.sha1()
    md5 = hashlib.md5()
    sha1.update(i_bytes)
    sha1.update(s_bytes)
    sha1.update(clientRandom_bytes)
    sha1.update(serverRandom_bytes)
    md5.update(s_bytes)
    md5.update(sha1.digest())
    return md5.digest()
def rdp_final_hash(k, clientRandom_bytes, serverRandom_bytes):
    md5 = hashlib.md5()
    md5.update(k)
    md5.update(clientRandom_bytes)
    md5.update(serverRandom_bytes)
    return md5.digest()
def rdp_calculate_rc4_keys(client_random, server_random):
    preMasterSecret = client_random[0:23+1] + server_random[0:23+1]
    masterSecret = rdp_salted_hash(preMasterSecret, b"A", client_random, server_random) + rdp_salted_hash(preMasterSecret, b"BB", client_random, server_random) + rdp_salted_hash(preMasterSecret, b"CCC", client_random, server_random)
    sessionKeyBlob = rdp_salted_hash(masterSecret, b"X", client_random, server_random) + rdp_salted_hash(masterSecret, b"YY", client_random, server_random) + rdp_salted_hash(masterSecret, b"ZZZ", client_random, server_random)
    initialClientDecryptKey128 = rdp_final_hash(sessionKeyBlob[16:31+1], client_random, server_random)
    initialClientEncryptKey128 = rdp_final_hash(sessionKeyBlob[32:47+1], client_random, server_random)
    macKey = sessionKeyBlob[0:15+1]
    return initialClientEncryptKey128, initialClientDecryptKey128, macKey, sessionKeyBlob
def rsa_encrypt(bignum, rsexp, rsmod):
    return pow(bignum, rsexp, rsmod)
def rdp_rc4_crypt(rc4obj, data):
    return rc4obj.crypt(data)
def int_to_bytestring(daInt):
    return daInt.to_bytes((daInt.bit_length() + 7) // 8, byteorder='little')
